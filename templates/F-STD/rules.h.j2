#ifndef RULES_{{ model.name }}_H
#define RULES_{{ model.name }}_H

#include <stdint.h>

#include "definitions_{{ model.name }}.h"
#include "defCommon_{{ model.name }}.h"

#ifndef MAX_L_NAME_{{ model.name }}
#error "MAX_L_NAME_{{ model.name }} not defined: check definitions_{{ model.name }}.h"
#endif

#ifndef N_INPUT_{{ model.name }}
#error "N_INPUT_{{ model.name }} not defined: check definitions_{{ model.name }}.h"
#endif

#ifndef N_OUTPUT_{{ model.name }}
#error "N_OUTPUT_{{ model.name }} not defined: check definitions_{{ model.name }}.h"
#endif

//! IF AND THEN STATEMENTS
typedef struct {
	char name[MAX_L_NAME_{{ model.name }}];		//!< Name of the variable
	char mf[MAX_L_NAME_{{ model.name }}];		//!< Member function of the variable
} ruleStatement_{{ model.name }};

//! RULE
typedef struct {
	ruleStatement_{{ model.name }} ifRules[N_INPUT_{{ model.name }}];		//!< Vector of "if statements"
	uint_t nIfRules;						//!< Number of "if statements"

	dataType thenValue;					//!< Value of correctness of the rule

	ruleStatement_{{ model.name }} thenRules[N_OUTPUT_{{ model.name }}];	//!< Vector of "then statements"
	uint_t nThenRules;						//!< Number of "then statements"
} rule_{{ model.name }};

//! RULE AFTER FINDING THE INDICES OF THE INPUTS AND MEMBERSHIP FUNCTIONS OF THE FUZZY LOGIC
typedef struct {
	uint_t ifRulesIndex[N_INPUT_{{ model.name }}];			//!< Vector of the indices of "if statements"
	uint_t ifRulesMFIndex[N_INPUT_{{ model.name }}];		//!< Vector of the indices of the mf of the "if statements"
	uint_t nIfRules;						//!< Number of "if statements"

	dataType thenValue;					//!< Value of correctness of the rule

	uint_t thenRulesIndex[N_OUTPUT_{{ model.name }}];		//!< Vector of the indices of the "then statements"
	uint_t thenRulesMFIndex[N_OUTPUT_{{ model.name }}];		//!< Vector of the indices of the mf of the "then statements"
	uint_t nThenRules;						//!< Number of "then statements"
} builtRule_{{ model.name }};

#undef max
#undef min

inline double min(double a, double b) {
	return a<=b ? a : b;
}

inline double multiply(double a, double b) {
	return a*b;
}

inline double max(double a, double b){
	return a>=b ? a : b;
}

#endif
