#include "definitions_{{ model.name }}.h"
#include "fuzzyLogic_{{ model.name }}.h"

int newState_{{ model.name }}(fuzzyLogic_{{ model.name }} * fl) {

	/*
	 * INPUT VARIABLES
	 */

	int flag;
	fuzzyInput_{{ model.name }} fi[NINPUT_{{ model.name }}];

	{% for vin in model.input_var %}
	// Input variable: {{ vin.name }}
	{% if vin.description is defined %}
	// {{ vin.description }}
	{% endif %}
	memFunction MF_{{ vin.name }}[{{ vin.membership_functions | length }}];

	{% for mf in vin.membership_functions %}
	double poi_{{ vin.name }}_{{ mf.name }}[] = { {% for p in mf.parameters recursive %}{% if p is iterable %}{{ loop(p) }}{% else %}{{ p }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %} };
	createMemFunction(&(MF_{{ vin.name }}[{{ loop.index0 }}]), "{{ mf.name }}", {{ mfDict.get(mf.type) }}, poi_{{ vin.name }}_{{ mf.name }});
	{% endfor %}

	flag = createInput(&(fi[{{ loop.index0 }}]), {{ vin.name }}, MF_{{ vin.name }}, {{ vin.mfs | length }});
	if (flag < 0) {
		return 1;
	}

	{% endfor %}

	/*
	 * OUTPUT VARIABLES
	 */

	fuzzyOutput{{ model.name }} fo[NOUTPUT_{{ model.name }}];

	{% for vo in model.output_var %}
	// Output variable: {{ vo.name }}
	{% if vo.description is defined %}
	// {{ vo.description }}
	{% endif %}
	memFunction MF_{{ vo.name }}[{{ vo.membership_functions | length }}];

	{% for mf in vo.membership_functions %}
	double poi_{{ vo.name }}_{{ mf.name }}[] = { {% for p in mf.parameters recursive %}{% if p is iterable %}{{ loop(p) }}{% else %}{{ p }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %} };
	createMemFunction(&(MF_{{ vo.name }}[{{ loop.index0 }}]), "{{ mf.name }}", {{ mfDict.get(mf.type) }}, poi_{{ vo.name }}_{{ mf.name }});
	{% endfor %}

	flag = createOutput(&(fo[{{ loop.index0 }}]), {{ vo.name }}, MF_{{ vo.name }}, {{ vo.mfs | length }});
	if (flag < 0) {
		return 1;
	}

	{% endfor %}

	/*
	 * RULES
	 */

	rule rules[N_RULES_{{ model.name }}];

	{% for r in model.rules %}{% set outerLoop = loop %}
	rules[{{ loop.index0 }}].nIfRules = {{ r[0] | length }};

	{% for ir in r[0] %}
	strcpy(rules[{{ outerLoop.index0 }}].ifRules[{{ loop.index0 }}].name, "{{ ir[0] }}");
	strcpy(rules[{{ outerLoop.index0 }}].ifRules[{{ loop.index0 }}].mf, "{{ ir[1] }}");
	{% endfor %}

	rules[{{ loop.index0 }}].thenValue = {{ r[2] }};
	
	rules[{{ loop.index0 }}].nThenRules = {{ r[1] | length }};

	{% for tr in r[1] %}
	strcpy(rules[{{ outerLoop.index0 }}].thenRules[{{ loop.index0 }}].name, "{{ tr[0] }}");
	strcpy(rules[{{ outerLoop.index0 }}].thenRules[{{ loop.index0 }}].mf, "{{ tr[1] }}");
	{% endfor %}

	{% endfor %}

	/*
	 * LOGIC
	 */

	flag = createLogic_{{ model.name }}(fl, &fi, &fo, rules);
	if ( flag < 0 ) {
		return 3;
	}

	return 0;
}
