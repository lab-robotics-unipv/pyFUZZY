#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>

#include "fuzzyLogic_{{ model.name }}.h"

/*! CONSTRUCTOR OF THE FUZZY LOGIC
 *		output			fl			Fuzzy logic to init
 *		input			inputs		Vector of inputs of the logic
 *		input			outputs		Vector of outputs of the logic
 *		input			rules		Vector of rules to add to the logic
 *
 *		return						Flag: -1 if error, 0 otherwise
 */
int_t createLogic_{{ model.name }}(fuzzyLogic_{{ model.name }} * fl, fuzzyInput_{{ model.name }} * inputs, fuzzyOutput_{{ model.name }} * outputs, rule_{{ model.name }} * r) {
	if (fl == NULL || inputs == NULL || outputs == NULL || r == NULL) {
		return -1;
	}
	memcpy(fl->fInput, inputs, N_INPUT_{{ model.name }}*sizeof(fuzzyInput_{{ model.name }}));
	memcpy(fl->fOutput, outputs, N_OUTPUT_{{ model.name }}*sizeof(fuzzyOutput_{{ model.name }}));

	int i, j, k;
	int index, index2;
	for (i = 0; i < N_RULES_{{ model.name }}; i++) {
		fl->rules[i].nIfRules = r[i].nIfRules;
		fl->rules[i].thenValue = r[i].thenValue;
		fl->rules[i].nThenRules = r[i].nThenRules;

		for (j = 0; j < r[i].nIfRules; j++) {
			index = getInputFromName_{{ model.name }}(fl, r[i].ifRules[j].name);
			if (index<0) {
				return -1;
			} else {
				fl->rules[i].ifRulesIndex[j] = index;
			}
			index2 = getInputMFFromName_{{ model.name }}(&(fl->fInput[index]), r[i].ifRules[j].mf);
			if (index2 < 0) {
				return -1;
			} else {
				fl->rules[i].ifRulesMFIndex[j] = index2;
			}
		}

		for (j = 0; j < r[i].nThenRules; j++) {
			index = getOutputFromName_{{ model.name }}(fl, r[i].thenRules[j].name);
			if (index<0) {
				return -1;
			} else {
				fl->rules[i].thenRulesIndex[j] = index;
			}
			index2 = getOutputMFFromName_{{ model.name }}(&(fl->fOutput[index]), r[i].thenRules[j].mf);
			if (index2 < 0) {
				return -1;
			} else {
				fl->rules[i].thenRulesMFIndex[j] = index2;
			}
		}
	}
	
	for (i = 0; i < N_INPUT_{{ model.name }}; i++) 
		for (i = 0; i < MAX_N_MF_INPUT_{{ model.name }}; i++) 
			fl->fuzzified[ i * MAX_N_MF_INPUT_{{ model.name }} + j];
			
	return 0;
}

int_t createFindLogic_{{ model.name }}(fuzzyLogic_{{ model.name }} * fl, fuzzyInput_{{ model.name }} * inputs, fuzzyOutput_{{ model.name }} * outputs){
	if (fl == NULL || inputs == NULL || outputs == NULL ) {
		return -1;
	}
	memcpy(fl->fInput, inputs, N_INPUT_{{ model.name }}*sizeof(fuzzyInput_{{ model.name }}));
	memcpy(fl->fOutput, outputs, N_OUTPUT_{{ model.name }}*sizeof(fuzzyOutput_{{ model.name }}));
	
	return 0;
}

/*! FUZZIFY THE INPUTS
 *		input/output	fl					Fuzzy logic
 *		input			inputs				Inputs of the fuzzy logic			
 */
//The output type of fuzzifiedValues should be changed to pointer( no more pointer to pointer)
void fuzzify_{{ model.name }}(fuzzyLogic_{{ model.name }} * fl, dataType * inputs) {
	int i;
	for ( i = 0; i < N_INPUT_{{ model.name }}; i++) {
			getPercentageFromInput_{{ model.name }}( &(fl->fInput[i]), inputs[i], &(fl->fuzzified[i * MAX_N_MF_INPUT_{{ model.name }}]));
	}
}

/*! EVALUATE THE RULES GIVEN THE FUZZIFIED INPUTS
 *		input/output		fl			Fuzzy logic
 *
 *		return							-1 if smtg went wrong, 0 otherwise
 */
int_t evaluateRules_{{ model.name }}(fuzzyLogic_{{ model.name }} * fl) {
	uint_t i, j;

	// Set evaluations to zeros
	for ( i = 0; i < N_OUTPUT_{{ model.name }}; i++) {
		for ( j = 0; j < fl->fOutput[i].nMF; j++) {
			fl->evaluated[i * MAX_N_MF_OUTPUT_{{ model.name }} + j] = 0;
		}
	}

	dataType minValue;
	for ( i = 0; i < N_RULES_{{ model.name }}; i++) {
		minValue = 1;	//!< The values are always less than 1
		builtRule_{{ model.name }} * r = &(fl->rules[i]);
		for ( j = 0; j < r->nIfRules; j++) {
			// TODO: possibility to choose the function
			//minValue *= fl->fuzzified[(r->ifRulesIndex[j]) * MAX_N_MF_INPUT_{{ model.name }} + r->ifRulesMFIndex[j]];
			minValue = min(minValue, fl->fuzzified[(r->ifRulesIndex[j]) * MAX_N_MF_INPUT_{{ model.name }} + r->ifRulesMFIndex[j]]);
		}

		minValue *= r->thenValue;
		
		dataType * e;
		for ( j = 0; j < r->nThenRules; j++) {
			e = &(fl->evaluated[(r->thenRulesIndex[j]) * MAX_N_MF_OUTPUT_{{ model.name }} + r->thenRulesMFIndex[j]]);
			//*e *= minValue;//*e == 0 ? minValue : MIN(minValue, *e);
			*e = *e == 0 ? minValue : max(minValue, *e);
		}
	}
	return 0;
}

/*! DEFUZZIFY THE EVALUATED RULES
 *		input			fl				Fuzzy logic
 *		output			outputs			Vector of the outputs of the fuzzy control
 *
 *		return							-1 if smtg went wrong, 0 otherwise
 */
int_t defuzzify_{{ model.name }}(fuzzyLogic_{{ model.name }} * fl, dataType * outputs) {
	uint_t i, j;
	dataType sum = 0;
	dataType aux = 0;
	
	for ( i = 0; i < N_OUTPUT_{{ model.name }}; i++) {
		for ( j = 0; j < fl->fOutput[i].nMF; j++) {
			sum = sum + fl->evaluated[i * MAX_N_MF_OUTPUT_{{ model.name }} + j];
			aux = aux + (fl->fOutput[i].mf[j].poi[0]) * (fl->evaluated[i * MAX_N_MF_OUTPUT_{{ model.name }} + j]);
		}
		if (sum != 0)
			outputs[i] = aux/sum;
		aux = 0;
		sum = 0;
	}
	
}

/*! ADD A RULE TO THE FUZZY LOGIC
 *		output			fl			Fuzzy logic 
 *		input			rules		Rule to add to the logic
 * 		input			indexRule	Index of the rule to be added
 *
 *		return						Flag: -1 if error, 0 otherwise
 */
int_t addRule_{{ model.name }}(fuzzyLogic_{{ model.name }} * fl, rule_{{ model.name }} * r, uint_t indexRule){
	
	if (fl == NULL || r == NULL)
		return -1; 
		
	fl->rules[indexRule].nIfRules = r->nIfRules;
	fl->rules[indexRule].thenValue = r->thenValue;
	fl->rules[indexRule].nThenRules = r->nThenRules;
	
	uint_t j;
	int_t index,index2;
	
	for (j = 0; j < r->nIfRules; j++) {
			index = getInputFromNameIn_{{ model.name }}(fl->fInput, N_INPUT_{{ model.name }}, r->ifRules[j].name);
			if (index < 0) {
				return -1;
			} else {
				fl->rules[indexRule].ifRulesIndex[j] = index;
			}
			index2 = getInputMFFromName_{{ model.name }}(&(fl->fInput[index]), r->ifRules[j].mf);
			if (index2 < 0) {
				return -1;
			} else {
				fl->rules[indexRule].ifRulesMFIndex[j] = index2;
			}
		}
	return -1;
}

/*! FIND INPUT INDEX GIVEN NAME
 *		input			fl				Fuzzy logic
 *		input			name			Name of the input
 *
 *		return							Index of the input
 */
int_t  getInputFromName_{{ model.name }}(fuzzyLogic_{{ model.name }} * fl, char * name) {
	int i;
	for ( i = 0 ; i < N_INPUT_{{ model.name }}; i++) {
		if (strcmp(fl->fInput[i].name, name) == 0) {
			return i;
		}
	}
	return -1;
}

/*! FIND OUTPUT INDEX GIVEN NAME
 *		input			fl				Fuzzy logic
 *		input			name			Name of the output
 *
 *		return							Index of the output
 */
int_t  getOutputFromName_{{ model.name }}(fuzzyLogic_{{ model.name }} * fl, char * name) {
	int i;
	for ( i = 0 ; i < N_OUTPUT_{{ model.name }}; i++) {
		if (strcmp(fl->fOutput[i].name, name) == 0) {
			return i;
		}
	}
	return -1;
}

/*! CALCULATE THE INDEX, GIVEN AN INPUT TO THE FUZZY SYSTEM. 
 * 	THIS FUNCTIONS WORKS ***ONLY*** FOR F-IND SYSTEMS.
 * 	IN ORDER TO SEE HOW F-IND WORKS LOOK AT THE DOCUMENTATION
 *		input			fl				Fuzzy logic
 *
 *		return							Index 
 */
dataType calculateIndex_{{ model.name }}(fuzzyLogic_{{ model.name }} * fl){
	

		//double[] membership = new double[nv];
		
		//Setting the number of input variables
		int nv = N_INPUT_{{ model.name }};
		//Setting the number of total rules
		int n_rules;
		dataType membership[nv]; 
		dataType var[MAX_N_MF_OUTPUT_{{ model.name }}];
		dataType weight_sum, sum_membership_prod, membership_prod, div;
		// counter for the index of each variable
		int count[nv];
		
		int i,j;
		
		// Checking if there are no input variables
		if (nv <= 0)
			return 2;
		
		// gets the maximum number of membership functions among all variables 
		int maxMF = MAX_N_MF_INPUT_{{ model.name }};
		
		// indexes of the active MFs in each variable
		// an active MF is one MF having output != 0 for the given input value
		int activeMF[nv][maxMF];
		
		// number of active functions for each variable
		int naf[nv];
		
		// resets the content of arrays
		for (i = 0; i < nv; i++) {
			naf[i] = 0;
			count[i] = 0;
			for (j = 0; j < maxMF; j++) {
				activeMF[i][j] = -1;
			}
		}
			
		// initialize the arrays
		for (i = 0; i < nv; i++) {
			fuzzyInput_{{ model.name }} currVar = fl->fInput[i];
			for (j = 0; j < currVar.nMF; j++) {
				if (fl->fuzzified[i * MAX_N_MF_INPUT_{{ model.name }} + j] != 0.0) {
					activeMF[i][naf[i]] = j; 
					(naf[i])++;
				}
			}
		}
		
		//for (i = 0; i < nv; i++){
			//for (j = 0; j < MAX_N_MF_INPUT_{{ model.name }}; j++) 
				//printf("%i\t", activeMF[i][j]); 
			//printf("\n");
	//	}
		// calculate the total number of rules
		n_rules = 1;
		for (i = 0; i < nv; i++) {
			n_rules *= naf[i];
		}
		
		//printf("\n The number of rules is : \t %i \n", n_rules);
		
		for (i = 0; i < MAX_N_MF_OUTPUT_{{ model.name }}; i++) {
			fl->evaluated[i] = 0.0;
			var[i] = 0.0;
		}
		

		//one loop for each rule
		sum_membership_prod = 0.0;
		for (i = 0; i < n_rules; i++) {
			weight_sum = 0.0;
			membership_prod = 1.0;
			
			//printf("\n Rule number %i : \n", i);
			
			// one loop for each value of the rule
			for (j = 0; j < nv; j++) {
				fuzzyInput_{{ model.name }} currVar = fl->fInput[j];
				memFunction_{{ model.name }} mf = currVar.mf[ (activeMF[j][count[j]]) ];

				// sum the contribution of the j-th variable
				weight_sum += mf.normalizedWeight;

				// calculate the membership grade of j-th variable
				//membership[j] = getPercentage( &mf , input[j]); //TODO: CAMBIARE CON FUZZIFIED AL POSTO DI GETPERCETNAGE
				//membership[j] = fl->fuzzified[ j * MAX_N_MF_INPUT + count[j] ];
				//membership[j] = fl->fuzzified[ j * MAX_N_MF_INPUT + (count[j]) ];
				membership[j] = fl->fuzzified[ j * MAX_N_MF_INPUT_{{ model.name }} + (activeMF[j][count[j]])  ];
				

				// calculate the AND operator among membership grades
				membership_prod *= membership[j];
				
				//printf("\tVariable : %s", currVar.name);
				//printf("\t  MF name : %s \t membership %f\n", mf.name, membership[j]);
			}
			
			//printf("\n\tWeight sum is : %f   and Membership_prod is : %f\n", weight_sum, membership_prod);
			
			// sum the column of ANDs
			sum_membership_prod += membership_prod;

			for (j = 0; j < MAX_N_MF_OUTPUT_{{ model.name }}; j++) {
				memFunction_{{ model.name }} eMF = fl->fOutput->mf[j]; //TODO : si può spostare fuori
				var[j] += getPercentage_{{ model.name }}( &eMF, weight_sum) * membership_prod;
				
				//printf("\t var[%d] is : %f\n", j, var[j]);
			}
						
			count[0]++;
			for (j = 0; j < nv - 1; j++) {
				count[j + 1] += count[j] / naf[j];
				count[j] %= naf[j];
			}
		}

		//double es_n_func = ef.getFuncNumber();
		//div = 1.0 / (es_n_func - 1.0);
		
		div = 1.0 / (MAX_N_MF_OUTPUT_{{ model.name }} - 1.0);
		dataType indexValue = 0.0;
		
		//printf("\n div is : %f\n", div);
		//for ( j = 0; j< MAX_N_MF_OUTPUT_{{ model.name }}; j++)
			//printf("var[%d] is : %f\n", j, var[j]);
			
		for (i = 0; i < MAX_N_MF_OUTPUT_{{ model.name }}; i++) {
			fl->evaluated[i] = var[i] / sum_membership_prod;
			indexValue += div * i * fl->evaluated[i];
			
			//printf("\nFuzzy evaluated is : % f and indexValue increasing is : %f\n", fl->evaluated[i], indexValue); 
		}
		
		indexValue = 100 * indexValue;


		return (indexValue);
	}

